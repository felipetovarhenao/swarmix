/* 
    Natural exponent
*/
float exp(float n) {
    return e^n
}

/*
    Logarithm base n
*/
float logn(float x, float n) {
   return log(x)/log(n) 
}

/*
    Logarithm base 2
*/
float log2(float x) {
   return logn(x, 2)
}


/*
    Non-recursive implementation of factorial function
    NOTE: recursive version seems to yield errors
*/
float fact(float n) {
    float r, i
    r = 1
    n = abs(n)
    if (n > 1) {
        for (i = 0; i < n; i += 1) {
            r *= n - i
        }
    }
    return r
}

/*
    Modulus operator
*/
float modn(float n, float m) {
    return n - m*trunc(n/m)
}

/*
    Returns the sign of a value.
*/
float sign(float x) {
    if (x > 0) {
        return 1
    }
    return -1
}

/*
    The cmix implementation of round doesn't behave as expected with negative values.
    As such, use this function as a temporary replacement.
*/
float fround(float x) {
    return trunc(abs(x) + 0.5) * sign(x)
}

/*
    Tangent
*/
float tan(float x) {
    return sin(x)/cos(x)
}

/*
    Factorial lookup function for trig functions
*/
float _precomp_fact(float i, float m) {
    return _PRECOMP_FACTORIALS[m][i]
}

/*
    Generalized function definition for sin, cos, sinh, and cosh
    if h == 1 then hyperbolic
    if m == 1 then sin else cos
*/
float _hypersincos(float x, float m, float h) {
    // wrap value around to prevent precision errors
    x = modn(x, TWO_PI)

    // initialize variables
    float y, v, c, i, s
    y = 0

    // set base to -1 is function is hyperbolic
    s = h * 2 - 1
    
    // compute terms
    for (i = 0; i < 10; i += 1) {
        c = s^i
        v = 2 * i + m
        y += c * (x^v) / _precomp_fact(i, m) 
    }
    return y 
}

/*
    Sine function
*/
float sin(float x) {
    return _hypersincos(x, 1, 0)
}

/*
    Cosine function
*/
float cos(float x) {
    return _hypersincos(x, 0, 0)
} 

/*
    Hyperbolic sine function
*/
float sinh(float x) {
    return _hypersincos(x, 1, 1)
}

/*
    Hyperbolic cosine function
*/
float cosh(float x) {
    return _hypersincos(x, 0, 1)
}

/*
    Hyperbolic tangent function
*/
float tanh(float x) {
    return (exp(x) - exp(-x))/(exp(x) + exp(-x))
}

/* 
    Returns the p-order Minkwoski distance between lists a and b
*/
float minkowski(list a, list b, float p) {
    if (len(a) != len(b)) {
        print('lists must be of same length')
        exit()
    }
    
    float i, s
    for (i = 0; i < len(a); i += 1) {
        s += abs(a[i] - b[i])^p
    }

    return s^(1/p)
}

/* 
    Returns the Euclidean distance between lists a and b
*/
float euclid(list a, list b) {
    return minkowski(a, b, 2)
}

/* 
    Returns the Manhattan distance between lists a and b
*/
float manhattan(list a, list b) {
    return minkowski(a, b, 1)
}

/* 
    Returns the weighted Euclidean distance between lists a and b with weights w
*/
float weuclid(list a, list b, list w) {
    if (len(a) != len(b) || len(w) != len(a)) {
        print('lists must be of same length')
        exit()
    }
    
    float i, s
    for (i = 0; i < len(a); i += 1) {
        s += w[i] * (a[i] - b[i])^2
    }

    return s^0.5
}

/* 
    Scaling function
*/
float remap(float x, float inmin, float inmax, float outmin, float outmax) {
    return ((x - inmin) / (inmax - inmin)) * (outmax - outmin) + outmin
}

/*
    Clips input value with lower and upper bounds
*/
float clip(float x, float l, float u) {
    float y
    if (x < l) {
        y = l
    } else if (x > u) {
        y = u
    } else {
        y = x
    }
    return y
}

/* 
    Greatest common denominator
*/
float gcd(float a, float b) {
    if (b == 0) {
        return a
    }
    return gcd(b, a % b)
}
