/*
    Shorthand utility for simple loops
*/
list iter(float N, mfunction f) {
    float i
    list y
    y = {}
    for (i = 0; i < N; i+= 1) {
        y[i] = f(i)
    }
    return y
}

/*
    Recursively applies a function f to every element in list x
    NOTE: As of 9/30/23, the max. recursion depth level is 2 :(
*/
list mapelem(list x, mfunction f) {
    float i
    list y
    y = {}
    for (i = 0; i < len(x); i += 1) {
        if (type(x[i]) == 'list') {
            y[i] = mapelem(x[i], f)
        } else {
            y[i] = f(x[i])
        }
    }
    return y
}

/*
    Deep-copies a list x.
*/
list deepcopy(list x) {
    float i
    list y
    y = {}
    for (i = 0; i < len(x); i += 1) {
        if (type(x[i]) == 'list') {
            y[i] = deepcopy(x[i])
        } else {
            y[i] = x[i]
        }
    }
    return y
}

/* 
    Reverses the order of element in a list x in place
*/
list rev(list x) {
    float i, j, N
    N = len(x)

    list tmp
    tmp = {}

    for (i = 0; i < trunc(N / 2); i += 1) {
        j = N-i-1
        tmp[0] = x[j]
        x[j] = x[i]
        x[i] = tmp[0]
    }
    return x
}


/*
    Returns the 1st derivative or deltas between adjacent elements
*/
list x2dx(list x) {
    float i
    list dx
    dx = {}
    for (i = 0;  i < len(x) - 1; i += 1) {
        dx[i] = x[i+1] - x[i] 
    }
    return dx 
}

/*
    Applies the input deltas or derivatives to the starting valeu
*/
list dx2x(list dx, float s) {
    float i
    list x
    x = {s}
    for (i = 1; i < len(dx); i += 1) {
        x[i] = x[i-1] + dx[i-1] 
    }
    return x 
}

/*
    Dummy function
*/
float _thru(float x) {
    return x
}

/* 
    Sorts a list numerically in place (Bubble-sort). An optional access function can be given to sort non-float elements
*/
list sort(list x, mfunction f) {
    float i, j, n
    list tmp
    n = len(x)

    if (!f) {
        f = _thru
    }
    for (i = 0; i < n - 1; i += 1) {
        for (j = 0; j < n - i - 1; j += 1) {
            if (f(x[j]) > f(x[j + 1])) {
                tmp[0] = x[j]
                x[j] = x[j + 1]
                x[j + 1] = tmp[0]
            }
        }
    }
    return x
}

/*
    Slices a list. Negative indices for right-to-left indexing are allowed.
*/
list slice(list x, float n) {
    float i, N
    N = len(x)

    if (n < 0) {
        n = max(0, N+n)
    }
    
    list l, r
    l = {}
    r = {}
    for (i = 0; i < N; i += 1) {
        if (i < n) {
            l[i] = x[i]
        } else if (i >= n) {
            r[i - n] = x[i]
        }
    }
    return {l, r}
} 

/*
    Groups list elements into g-sized sub-lists
*/
list group(list l, float g) {
    float i, j
    list lout
    lout = {}
    j = 0
    for (i = 0; i < round(len(l)/g); i += 1) {
        list tl
        tl = {}
        for (j = 0; j < g; j += 1) {
            float li
            li = j + (g*i)
            if (li < len(l)) {
                tl[j] = l[j + (g*i)]
            }
        }
        lout[i] = tl
    }
    return lout
}

/*
    Merges two lists
*/
list merge(list la, list lb) {
    float i
    list lout
    lout = la
    for (i = 0; i < len(lb); i += 1) {
        lout[len(lout)] = lb[i]
    }
    return lout
}

/*
    Matrix transtrindexition
*/
list mattrans(list mat) {
    list out
    float row, col, nrows, ncols
    out = {}
    nrows = len(mat)
    ncols = len(mat[0])
    for (col = 0; col < ncols; col += 1) {
        list outRow
        outRow = {}
        for (row = 0; row < nrows; row += 1) {
            list thisRow
            thisRow = mat[row]
            outRow[row] = thisRow[col]
        }
        out[col] = outRow
    }
    return out
}


/*
    Returns the elements between starting (inclusive) and ending (non-inclusive) indices.
*/
list indexrange(list l, float st, float end) {
    float i
    list out
    out = {}
    end = min(end, len(l))
    for (i = 0; i < abs(end-st); i += 1) {
        out[i] = l[st + i]
    }
    return out
}

/*
    Generates frames or windows from an input array
*/
list frames(list l, float ws, float hs) {
    list out
    if (hs > 0) {
        float i, k
        out = {}
        k = 0
        for (i = 0; i < len(l) - ws + 1; i += hs) {
            out[k] = indexrange(l, i, i + ws)
            k += 1
        }
    }
    return out
}

/*
    Performs deep equality comparison between 2 lists
*/
float deepeq(list a, list b) {
    float y, i, N
    N = len(a)
    if (N != len(b)) {
        return 0
    }
    y = 1
    for (i = 0; i < len(a); i += 1) {
        if ((type(a[i]) == type(b[i])) && (type(a[i]) == "float" || type(a[i]) == "string")) {
            if (a[i] != b[i]) {
                y = 0
                i = N
            }
        } else if (type(a[i]) == "list" && type(b[i]) == "list") {
            if (!deepeq(a[i], b[i])) {
                y = 0
                i = N
            }
        } else {
            y = 0
            i = N
        }
    }
    return y
}

/*
    Recursively adds all values in a list
*/
float reduce(list l) {
    float i, out
    out = 0
    for (i = 0; i < len(l); i += 1) {
        if (type(l[i]) == "float") {
            out += l[i]
        } else if (type(l[i]) == "list") {
            float temp
            temp = reduce(l[i])
            out += temp
        }
    }
    return out
}

/*
    Removes duplicate elements in a list
*/
list thin(list l) {
    float i, j, k
    list lout
    k = 1
    lout = {l[0]}
    for (i = 1; i < len(l); i += 1) {
        float count
        count = 0
        for (j = 0; j < len(lout); j += 1) {
            if ((type(l[i]) == "float" || type(lout[j]) == "string") && type(lout[j]) == type(l[i])) {
                if (l[i] == lout[j]) {
                    count += 1
                }
            } else if (type(l[i]) == "list" && type(lout[j]) == type(l[i])) {
                if (deepeq(l[i], lout[j])) {
                    count += 1
                } 
            }
        }
        if (count == 0) {
            lout[k] = l[i]
            k += 1
        }  
    }
    return lout
}

/*
    Returns an index map of a list
*/
list indexmap(list l) {
    float i, j, k
    list dict, out
    dict = thin(l)
    out = {}
    k = 0
    for (j = i; j < len(l); j += 1) {
        for (i = 0; i < len(dict); i += 1) {
            if (type(dict[i]) != "list" && type(dict[i]) == type(l[j])) {
                if (dict[i] == l[j]) {
                    out[k] = i
                    k += 1
                }
            } else if (type(dict[i]) == "list" && type(dict[i]) == type(l[j])) {
                if (deepeq(dict[i], l[j])) {
                    out[k] = i
                    k += 1
                } 
            }
        }
    }
    return out
}

/*
    Returns the elements in list x at indices l
*/
list lookup(list x, list l) {
    float i
    list y
    y = {}
    for (i = 0; i < len(l); i += 1) {
        y[i] = x[l[i]]
    }
    return y
}

/*
    Flattens a list
*/
list flat(list l) {
    float i, j
    list out
    j = 0
    for (i = 0; i < len(l); i += 1) {
        if (type(l[i]) != "list") {
            out[j] = l[i]
            j += 1
        } else {
            l[i] = flat(l[i])
            out = merge(out, l[i])
            j += 1
        }
    }
    return out
}

/* 
    Normalizes a list such that the sum of all elements is 1
*/
float normalize(list l) {
    float i, s
    list n

    n = {}
    for (i = 0; i < len(l); i += 1) {
        s += l[i]
    }

    if (s == 0) {
        print("Warning: list not normalized â€” all elements add up to 0")
        return l
    }

    for (i = 0; i < len(l); i += 1) {
        n[i] = l[i] / s
    }
    
    return  n
}

/* 
    Private generalized function declaration for nearest element search
*/
list _generalized_nearest(list l, list x, mfunction f) {
    // initialize best distance, match, and index
    float i, bd, bi, d
    list bm
    bm = {}
    bd = INF
    for (i = 0; i < len(l); i += 1) {
        d = f(l[i], x)
        if (d < bd) {
            bm[0] = l[i]
            bd = d
            bi = i
        }
    }
    return {bm[0], bi, bd}
}

/* 
    Private function declaration for absolute difference
*/
float _absdiff(float a, list b) {
    return abs(a-b)
}

/* 
    Returns the closest element in list l to float element x, as FloatNeighbor struct (value, index, distance)
    NOTE: using FloatNeighbor as a return type does not work
*/
float fclosest(list l, float x) {
    list y
    y = _generalized_nearest(l, {x}, _absdiff)

    struct FloatNeighbor n
    n.value = y[0]
    n.index = y[1]
    n.distance = y[2]

    return n
}

/* 
    Returns the closest element in list l to list element x, as ListNeighbor struct (value, index, distance)
    If no distance function is provided, euclidean distance is used.
    NOTE: using ListNeighbor as a return type does not work
*/
list lclosest(list l, list x, mfunction d) {
    list y

    if (!d) d = euclid

    y = _generalized_nearest(l, x, d)

    struct ListNeighbor n
    n.value = y[0]
    n.index = y[1]
    n.distance = y[2]

    return n
}

/*
    Repeats a list x, n times
*/
list repeatn(list x, float n) {
    list y
    y = {}
    
    float i
    for (i = 0; i < n; i += 1) {
        y = merge(y, x)
    }
    return y
}

/*
    Generates an n-step linear space from st to end
*/
list linspace(float st, float end, float n) {
    float i, r, s, a
    list y
    y = {}

    r = end - st
    s = r / (n - 1)
    a = st
    
    for (i = 0; i < n; i += 1) {
        y[i] = a
        a += s
    }

    return y
}