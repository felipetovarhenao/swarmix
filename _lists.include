/*
	Recursively applies a function to every element in the list
	NOTE: As of 9/30/23, the max. recursion depth level is 2 :(
*/
list mapelem(list x, mfunction f) {
	float i
	list y
	y = {}
	for (i = 0; i < len(x); i += 1) {
		if (type(x[i]) == 'list') {
			y[i] = mapelem(x[i], f)
		} else {
			y[i] = f(x[i])
		}
	}
	return y
}

/*
	Deep-copies input list.
*/
list deepcopy(list x) {
	float i
	list y
	y = {}
	for (i = 0; i < len(x); i += 1) {
		if (type(x[i]) == 'list') {
			y[i] = deepcopy(x[i])
		} else {
			y[i] = x[i]
		}
	}
	return y
}

/* 
	Reverses the order of element in a list
*/
list rev(list l) {
    float i
    list y
    y = {}
    for (i = 0; i < len(l); i += 1) {
        y[i] = l[len(l) - 1 - i]
    }
    return y
}


/*
	Returns the 1st derivative or deltas between adjacent elements
*/
list x2dx(list x) {
    float i
    list dx
    dx = {}
    for (i = 0;  i < len(x) - 1; i += 1) {
        dx[i] = x[i+1] - x[i] 
    }
    return dx 
}

/*
	Applies the input deltas or derivatives to the starting valeu
*/
list dx2x(list dx, float s) {
    float i
    list x
    x = {s}
    for (i = 1; i < len(dx); i += 1) {
        x[i] = x[i-1] + dx[i-1] 
    }
    return x 
}

/* 
	Sorts a list numerically
*/
list sort(list inl) {
    list l
    l = inl
	float i, j, n
	n = len(l)
	for (i = 0; i < n - 1; i += 1) {
		for (j = 0; j < n - i - 1; j += 1) {
			if (l[j] > l[j + 1]) {
				float tmp
				tmp = l[j]
				l[j] = l[j + 1]
				l[j + 1] = tmp
			}
		}
	}
	return l
}

/*
	Slices a list
*/
list slice(list l, float n) {
    float i
    list la, lb, lout
    la = {}
    lb = {}
    for (i = 0; i < len(l); i += 1) {
        if (i < n) {
            la[i] = l[i]
        } else if (i >= n) {
            lb[i - n] = l[i]
        }
    }
    lout = {la, lb}
    return lout
} 


/*
	Slices a list with reversed index
*/
list ecils(list l, float n) {
    float i
    n = len(l) - n
    list la, lb, lout
    la = {}
    lb = {}
    for (i = 0; i < len(l); i += 1) {
        if (i < n) {
            la[i] = l[i]
        } else if (i >= n) {
            lb[i - n] = l[i]
        }
    }
    lout = {la, lb}
    return lout
} 

/*
	Groups list elements into g-sized sub-lists
*/
list group(list l, float g) {
    float i, j
    list lout
    lout = {}
    j = 0
    for (i = 0; i < round(len(l)/g); i += 1) {
        list tl
        tl = {}
        for (j = 0; j < g; j += 1) {
            float li
            li = j + (g*i)
            if (li < len(l)) {
                tl[j] = l[j + (g*i)]
            }
        }
        lout[i] = tl
    }
    return lout
}

/*
	Merges two lists
*/
list merge(list la, list lb) {
    float i
    list lout
    lout = la
    for (i = 0; i < len(lb); i += 1) {
        lout[len(lout)] = lb[i]
    }
    return lout
}

/*
	Matrix transposition
*/
list mattrans(list mat) {
	list out
	float row, col, nrows, ncols
	out = {}
	nrows = len(mat)
	ncols = len(mat[0])
	for (col = 0; col < ncols; col += 1) {
		list outRow
		outRow = {}
		for (row = 0; row < nrows; row += 1) {
			list thisRow
			thisRow = mat[row]
			outRow[row] = thisRow[col]
		}
		out[col] = outRow
	}
	return out
}


/*
	Returns the elements between starting (inclusive) and ending (non-inclusive) indices.
*/
list indexrange(list l, float st, float end) {
    float i
    list out
    out = {}
	end = min(end, len(l))
    for (i = 0; i < abs(end-st); i += 1) {
        out[i] = l[st + i]
    }
    return out
}

/*
	Generates frames or windows from an input array
*/
list frames(list l, float ws, float hs) {
    list out
    if (hs > 0) {
        float i, k
        out = {}
        k = 0
        for (i = 0; i < len(l) - ws + 1; i += hs) {
            out[k] = indexrange(l, i, i + ws)
            k += 1
        }
    }
    return out
}

/*
	Performs string-based equality comparison between 2 lists
*/
float compare(list la, list lb) {
    float out
    if (len(la) == len(lb)) {
        float i
        out = 1
        for (i = 0; i < len(la); i += 1) {
            if ((type(la[i]) == type(lb[i])) && (type(la[i]) == "float" || type(la[i]) == "string")) {
                if (la[i] != lb[i]) {
                    out = 0
                    i = len(la)
                }
            } else if (type(la[i]) == "list" && type(lb[i]) == "list") {
                if (!compare(la[i], lb[i])) {
                    out = 0
                    i = len(la)
                }
            } else {
                out = 0
                i = len(la)
            }
        }
    }
    return out
}

/*
	Recursively adds all values in a list
*/
float reduce(list l) {
    float i, out
    out = 0
    for (i = 0; i < len(l); i += 1) {
        if (type(l[i]) == "float") {
            out += l[i]
        } else if (type(l[i]) == "list") {
            float temp
            temp = reduce(l[i])
            out += temp
        }
    }
    return out
}

/*
	Removes duplicate elements in a list
*/
list thin(list l) {
    float i, j, k
    list lout
    k = 1
    lout = {l[0]}
    for (i = 1; i < len(l); i += 1) {
        float count
        count = 0
        for (j = 0; j < len(lout); j += 1) {
            if ((type(l[i]) == "float" || type(lout[j]) == "string") && type(lout[j]) == type(l[i])) {
                if (l[i] == lout[j]) {
                    count += 1
                }
            } else if (type(l[i]) == "list" && type(lout[j]) == type(l[i])) {
                if (compare(l[i], lout[j])) {
                    count += 1
                } 
            }
        }
        if (count == 0) {
            lout[k] = l[i]
            k += 1
        }  
    }
    return lout
}

/*
	Returns an index map of a list
*/
list indexremap(list l) {
    float i, j, k
    list dict, out
    dict = thin(l)
    out = {}
    k = 0
    for (j = i; j < len(l); j += 1) {
        for (i = 0; i < len(dict); i += 1) {
            if (type(dict[i]) != "list" && type(dict[i]) == type(l[j])) {
                if (dict[i] == l[j]) {
                    out[k] = i
                    k += 1
                }
            } else if (type(dict[i]) == "list" && type(dict[i]) == type(l[j])) {
                if (compare(dict[i], l[j])) {
                    out[k] = i
                    k += 1
                } 
            }
        }
    }
    return out
}

/*
	Flattens a list
*/
list flat(list l) {
    float i, j
    list out
    j = 0
    for (i = 0; i < len(l); i += 1) {
        if (type(l[i]) != "list") {
            out[j] = l[i]
            j += 1
        } else {
            l[i] = flat(l[i])
            out = merge(out, l[i])
            j += 1
        }
    }
    return out
}

/* 
    Normalizes a list such that the sum of all elements is 1
*/
float normalize(list l) {
    float i, s
    list n

    n = {}
    for (i = 0; i < len(l); i += 1) {
        s += l[i]
    }

    if (s == 0) {
        print("Warning: list not normalized â€” all elements add up to 0")
        return l
    }

    for (i = 0; i < len(l); i += 1) {
        n[i] = l[i] / s
    }
    
    return  n
}