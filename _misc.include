float r2dur(float d, float r) {
    float t, td
    t = log2(r)
    t = remap(t, 0, 1, 0, 0.012)
    t = t * 1000
    td = (t % 12) / 100
    t = trunc(t/10)
    return translen(d, t + td)
}

list numdist(list l, float d, float mode) {
    float i
    list out
    l = sort(l)
    if (mode == 0) { 
        for (i = 0; i < len(l); i += 1) {
            out[i] = (l[i] - l[0]) * d + l[0]
        }
    } else if (mode == 1) {
        for (i = 0; i < len(l); i += 1) {
            out[i] = l[0] * pow(l[i] / l[0], d)
        }     
    }
    return out
}

list rissOnsets(float T, float tau, float v) {
    float tl
    list teList
    teList = {}
    for (tl = 0;  tl <= T * pow(2, v);  tl += 1) {
        teList[tl] = tau * (log2((tl/T) + pow(2, v)) - v) 
    }
    return teList 
}

float rissRates(float T, list teList, float v) {
    float tau, te, i
    list rList
    rList = {}
    tau = teList[len(teList) - 1]
    for (i = 0; i < len(teList); i += 1) {
        te = teList[i]
        rList[i] = T * log(2) / tau * pow(2, te/tau + v)
    }
    return rList
}

list rissAmps(float T,  float numv, float v) {
    float i, len, incr, st
    list at 
    len = pow(2,v)
    st = PI * 2 / numv
    incr = st / pow(2,v) / T
    st *= v
    at = {}
    for (i = 0; i < len * T; i += 1) {
        at[i] = (cos((st + (incr * i))) * -0.5) + 0.5
    }
    return at
}



list findex(list l, float x) {
    float i, j
    list y
    j = 0
    for (i = 0; i < len(l); i += 1) {
        if (l[i] == x) {
            y[j] = i
            j += 1
        }
    }
    return y
}


list strindex(list l, string e) {
    float i, j
    list out
    j = 0
    for (i = 0; i < len(l); i += 1) {
        if (l[i] == e) {
            out[j] = i
            j += 1
        }
    }
    return out
}

list listindex(list l, list e) {
    float i, j
    string x
    x = l2str(e)
    list out
    j = 0
    out = {}
    for (i = 0; i < len(l); i += 1) {
        if (type(l[i]) == 'list' && l2str(l[i]) == x) {
            out[j] = i
            j += 1
        }
    }
    return out
}

list modsets(list l, list s) {
    float i, j
    list out
    for (i = 0; i < len(l); i += 1) {
        list sl
        for (j = 0; j < len(s); j += 1) {
            sl[j] = l[(s[j] + i) % len(l)]
        }
        out[i] = sl
    }
    return out
}

list markovBuild(list data, float order) { // condensed trial
    float i, j, k
    list matrix, postrans, ngrams, dict
    ngrams = frames(data, order, 1) // sequence of ngrams
    dict = thin(ngrams) // dictionary of unique states
    postrans = {} // matrix of possible states
    matrix = {} // matrix of transition/probabilities

    // populate a list (postrans) with lists of possible transitions for each unique ngram
    for (i = 0; i < len(dict); i += 1) { // iterate through each unique state
        current = dict[i] // each unique state
        list pstates, countList 
        pstates = {} // possible states
        countList = {} // count/number of repeated transitions per state
        k = 0 // index of possible states
        for (j = 0; j < len(ngrams); j += 1) { // iterate through ngram sequence
            if (deepeq(current, ngrams[j])) { // is current state = current ngram?
                if (j + 1 < len(ngrams)) { // filter out indexing past number of ngrams in sequence
                    pstates[k] = ngrams[j + 1] // include next ngram in sequence as possible transition
                    k += 1
                }
            }
        }
        for (j = 0; j < len(dict); j += 1) { // count repeated transition for each unique ngram
            float count, m
            count = 0
            list ngr
            ngr = dict[j] // current unique ngram
            for (k = 0; k < len(pstates); k += 1) { // iterate through possible transition states 
                if (compare(pstates[k], ngr)) { // if current possible state = unique ngram
                    count += 1 // add to count
                }
            }
            countList[j] = count // include final count for given state
        }
        if (reduce(countList) == 0) { // if no possible transitions
            float c
            for (c = 0; c < len(countList); c += 1) { // populate with 1 for equal probability
                countList[c] = 1
            }
        }
        countList = countList / reduce(countList) // get probabilities as decimals (sum = 1)
        matrix[i] = countList // assign probability to each state
    }
    return  {dict, matrix}
}

list markovRun(list dict, list m, float init, float times) {
    float i, j, k, s
    list pl, out, e
    s = init // initial state index
    k = 1 // output index
    e = dict[s] // element in output
    out = {e[0]} // output list
    for (i = 0; i < times - 1; i += 1) {
        list tpl // temporary list
        tpl = {}
        tr = m[s] // transition row
        for (j = 0; j < len(tr) * 2; j += 2) { // format list for pickwrand()
            tpl[j] = j/2 // state index
            tpl[j + 1] = tr[j/2] // transition probability
        }
        s = pickwrand(tpl) // weighted random choosing of new state index
        e = dict[s]
        out[k] = e[0]
        k += 1
    }
    return out
}

list markov(list d, float o, float t) {
    list l
    l = markovBuild(d, o)
    l = markovRun(l[0], l[1], 0, t)
    return l
}

float f2mel(float f) {
    return 1125 * ln(1 + (f/700))
}

float mel2f(float m) {
    return 700 * (exp(m/1125) - 1)
}

struct Complex {
    float re, float im
}

list dft(list s) {
    float N, n, k, thresh, theta
    list out
    N = len(s)
    thresh = exp(-10)
    theta = -2*PI
    for (k = 0; k < N/2; k += 1) {
        struct Complex val
        val.re = 0
        val.im = 0
        for (n = 0; n < N; n += 1) {    
            val.re = val.re + s[n] * cos((theta*n*k)/N)
            val.im = val.im + s[n] * sin((theta*n*k)/N)
        } 
        val.re = (val.re*2) / N
        val.im = (val.im*2) / N
        if (abs(val.re) < thresh) {
            val.re = 0
        }
        if (abs(val.im) < thresh) {
            val.im = 0
        }
        out[k] = val
    }
    return out
}


list icgen(list icList, float min, float max) {
    list out
    float i, j, last
    i = 1
    j = 0
    out = {min}
    while (out[len(out) - 1] < max) {
        ic = icList[j]
        out[i] = out[i-1] + ic
        i += 1
        j = (j + 1) % len(icList)
    }
    return out
}


// string lsys(list rules, string axiom, float gen) {
//     list alpha, prod
//     float i, g
//     string out
//     out = ""
//     rules = mattrans(rules)
//     alpha = rules[0]
//     prod = rules[1]
//     for (i = 0; i < len(axiom); i += 1) {
//         list tmpindex
//         tmpindex = strindex(alpha, axiom[i])
//         if (len(tmpindex) > 0) {
//             out = out + prod[tmpindex[0]]
//         }
//     }
//     gen -= 1
//     if (gen > 0) {
//         out = lsys(rules, out, gen)
//     } else {
//         return out
//     }
//     return out
// }







