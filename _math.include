float exp(float n) {
    return pow(e, n)
}

/*
    Logarithm base n
*/
float logn(float x, float n) {
   return log(x)/log(n) 
}

/*
    Logarithm base 2
*/
float log2(float x) {
   return logn(x, 2)
}


/*
    Non-recursive implementation of factorial function
    NOTE: recursive version seems to yield errors
*/
float fact(float n) {
    float r, i
    r = 1
    n = abs(n)
    if (n > 1) {
        for (i = 0; i < n; i += 1) {
            r *= n - i
        }
    }
    return r
}

/*
    Modulus operator
*/
float modn(float n, float m) {
    return n - m*trunc(n/m)
}

/*
    Returns the sign of a value.
*/
float sign(float x) {
    if (x > 0) {
        return 1
    }
    return -1
}

/*
    The cmix implementation of round doesn't behave as expected with negative values.
    As such, use this function as a temporary replacement.
*/
float fround(float x) {
    return trunc(abs(x) + 0.5) * sign(x)
}

/*
    Tangent
*/
float tan(float x) {
    return sin(x)/cos(x)
}

/*
    Generalized function definition for sin, cos, sinh, and cosh
    if h == 1 then hyperbolic
    if m == 1 then sin else cos
*/
float _hypersincos(float x, float m, float h) {
    // wrap value around to prevent precision errors
    x = modn(x, TWO_PI)

    // initialize variables
    float y, v, c, i, s
    y = 0

    // set base to -1 is function is hyperbolic
    s = h * 2 - 1
    
    // compute terms
    for (i = 0; i < 10; i += 1) {
        c = s^i
        v = 2 * i + m
        y += c * (x^v) / fact(v) 
    }
    return y 
}

/*
    Sine function
*/
float sin(float x) {
    return _hypersincos(x, 1, 0)
}

/*
    Cosine function
*/
float cos(float x) {
    return _hypersincos(x, 0, 0)
} 

/*
    Hyperbolic sine function
*/
float sinh(float x) {
    return _hypersincos(x, 1, 1)
}

/*
    Hyperbolic cosine function
*/
float cosh(float x) {
    return _hypersincos(x, 0, 1)
}

/*
    Hyperbolic tangent function
*/
float tanh(float x) {
    return (exp(x) - exp(-x))/(exp(x) + exp(-x))
}

/*
    Radian to degree conversion
*/
float radtodeg(float r) {
    return (r/PI)*180
}

/*
    Degree to radian conversion
*/
float degtorad(float d) {
    return (d/180)*PI
}

/*
    Polar to cartesian conversion
*/
list poltocar(float a, float m) {
    if (!m) m = 1
    return {cos(a) * m, sin(a) * m}
}

/*
    Euclidean distance
*/
float euclid(list a, list b) {
    if (len(a) != len(b)) {
        print('lists must be of same length')
        exit()
    }
    
    float i, s
    for (i = 0; i < len(a); i += 1) {
        s += (a[i] - b[i])^2
    }

    return s^0.5
}

/*
    Weighted Euclidean distance
*/
float weuclid(list a, list b, list w) {
    if (len(a) != len(b) || len(w) != len(a)) {
        print('lists must be of same length')
        exit()
    }
    
    float i, s
    for (i = 0; i < len(a); i += 1) {
        s += w[i] * (a[i] - b[i])^2
    }

    return s^0.5
}

/* 
    Scaling function
*/
float remap(float x, float inmin, float inmax, float outmin, float outmax) {
    return ((x - inmin) / (inmax - inmin)) * (outmax - outmin) + outmin
}

/* 
    Normalizes input list such that the sum of all elements is 1
*/
float normalize(list l) {
    float i, s
    list n

    n = {}
    for (i = 0; i < len(l); i += 1) {
        s += l[i]
    }

    if (s == 0) {
        print("Warning: list not normalized â€” all elements add up to 0")
        return l
    }

    for (i = 0; i < len(l); i += 1) {
        n[i] = l[i] / s
    }
    
    return  n
}

/*
    Clips input value with lower and upper bounds
*/
float clip(float x, float l, float u) {
    float y
    if (x < l) {
        y = l
    } else if (x > u) {
        y = u
    } else {
        y = x
    }
    return y
}